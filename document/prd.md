# PRD – **웹 기반 Dialogue Editor (프론트엔드-Only)**

> "Twine 느낌의 시각 편집 + 우측 폼 패널"—JSON/CSV Export 중심 MVP

---

## 1. 목표 및 배경

* **목적**: 개발 지식이 많지 않은 기획자가 대화 분기(텍스트 / 선택지 / 입력)를 시각적으로 작성하고, 검증된 JSON·CSV로 바로 내보내 개발 파이프라인에 투입할 수 있는 **브라우저 단독 툴**을 제공한다.
* **핵심 철학**: **컨텐츠 작성과 키 관리의 완전 분리** - 기획자는 실제 텍스트에만 집중하고, 로컬라이징 키는 백그라운드에서 자동 관리
* **비전**:

  1. **MVP** — 서버·로그인 없이 배포 가능한 SPA, 노드 기반 에디팅, JSON/CSV 입·출력, 로컬 임시 저장.
  2. **1차 개선** — 대화 시뮬레이터, 콜백 키 관리 페이지, 로컬라이징 전용 탭, 확장 메타데이터.
  3. **장기** — 협업·버전 관리, 번역 워크플로 자동화, 커스텀 조건식/스크립트 지원.

---

## 2. 대상 사용자

| 유형          | 니즈                                          |
| ----------- | ------------------------------------------- |
| 기획자 (주 사용자) | **실제 대화 내용만 작성**, 키 관리는 신경쓰지 않고 시나리오에 집중         |
| 개발자         | JSON 구조가 Typescript 타입과 1:1 대응, 수동 수정 필요 없음 |
| 번역·LQA      | CSV로 한글 원문과 key를 추출 → 외부 도구로 이어서 작업         |

---

## 3. 범위 정의

### 3.1 **MVP 기능 (필수)**

| #    | 기능                  | 상세                                                                                                           |
| ---- | ------------------- | ------------------------------------------------------------------------------------------------------------ |
| F-01 | **노드 캔버스**          | React Flow (or rete.js) 기반.<br>– drag-to-pan / scroll-to-zoom<br>– Toolbar: **"텍스트 / 선택지 노드 추가"** 버튼 (MVP는 2개 타입만)        |
| F-02 | **노드 생성 & 연결 UX**   | ① 빈 캔버스일 때 중앙 생성<br>② 이미 있으면 **가장 마지막에 생성한 노드의 아래쪽**에 gap(10px) 간격으로 배치<br>③ **선택지별 개별 연결**: Choice 노드에서 각 선택지 텍스트 오른쪽에 "+" 버튼 → 해당 선택지의 nextNodeKey로 새 노드 자동 생성·연결<br>**※ 노드 배치 규칙**: 마지막 생성 노드 기준 Y축 + 노드높이 + 10px 오프셋 (MVP 확정, 추후 변경 가능)                         |
| F-03 | **우측 속성 패널**        | 노드 클릭 시 열린다.<br>**실제 텍스트 입력**: `speakerText`, `contentText` (기획자가 보는 실제 내용)<br>**키 표시**: 입력 필드 아래 자동 생성된 키 표시<br>입력 즉시 캔버스 미리보기에 **실제 텍스트**로 반영                         |
| F-04 | **로컬 임시 저장**        | 변경 시 localStorage `autoSave_v1` 키에 debounce(1 s) 저장                                                          |
| F-05 | **Import / Export** | **Export**: JSON (.json) 또는 CSV (.csv) 중 **사용자 선택**하여 단일 파일 다운로드<br>**Import**: JSON 또는 CSV 파일 업로드 지원 (각각 다른 파싱 로직)<br>– Export 전 실시간 검증; 실패 시 상세 오류 모달                            |
| F-06 | **컨텐츠-키 분리 관리**       | **기획자 인터페이스**: 실제 텍스트만 입력/편집<br>**백그라운드 키 관리**: 자동 생성된 key-value 매핑 저장소<br>**키 표시**: 입력 필드 하단에 연결된 키 표시<br>**키 수정**: 두 단계 편집 (전체 수정 vs 새 키 분리)<br>**일괄 수정**: 같은 키를 사용하는 모든 텍스트 동시 수정 |
| F-07 | **유효성 검사**          | • dangling nextNodeKey (존재하지 않는 노드 참조), 누락 필드<br>• 중복 key 경고<br>**※ MVP에서는 순환 참조 허용** (루프 구조 지원)                                                          |
| F-08 | **레이아웃 저장**         | 노드 x-y 좌표를 JSON 에 포함해 재-로드 시 동일 레이아웃 복원                                                                      |

### 3.2 **비-MVP (추후 개선 기록)**

* **G-01: 한글 원문·key 동시 입력/수정용 로컬라이징 전용 탭** ← **우선순위 상승**
* G-02: 플로우 시뮬레이터 (플레이 모드)
* G-03: 콜백 키 CRUD 페이지 + 검색
* G-04: 커스텀 메타데이터(감정, 카메라, SFX) 확장
* G-05: 버전 관리(Git)·다중 사용자 협업
* **G-06: InputDialogue 노드 생성 및 런타임 속성 지원**
  - 사용자 입력 노드 생성 기능 (정규식, placeholder, maxLength 등)
  - 입력 유효성 검사 및 에러 메시지 설정
  - 입력값 변수 저장 및 조건부 분기 연결
* **G-07: 순환 참조 감지 및 경고 시스템**
  - 노드 간 순환 참조 탐지 알고리즘
  - 루프 경로 시각화 및 경고 메시지
  - 의도적 루프 vs 실수 구분을 위한 사용자 선택 옵션

### 3.3 **Out of Scope (MVP)**

* 서버 API / DB
* 실시간 협업, 소켓通信
* 번역 파일 병합·포맷 변환(PO/XLIFF) 자동화
* **완전 오프라인 지원** (CDN 리소스, 웹폰트 등은 허용)

---

## 4. 데이터 모델 (MVP)

> **핵심 설계**: 컨텐츠(실제 텍스트)와 키(로컬라이징)의 완전 분리

### 4.1 **데이터 계층 구조**

```
TemplateDialogues (템플릿 단위)
├── Scene (노드 묶음 - 하나의 대화 흐름)
│   └── EditorNodeWrapper (개별 대화 노드)
│       └── Dialogue (실제 대화 데이터 - 키 참조만)
└── LocalizationStore (key-value 매핑 저장소)
    └── LocalizationEntry (키별 텍스트 데이터)
```

### 4.2 **타입 정의**

```ts
// 백그라운드 key-value 저장소
interface LocalizationEntry {
  ko: string;           // 한국어 원문 (기획자가 입력한 실제 텍스트)
  usedBy: string[];     // 이 키를 사용하는 nodeKey들
  createdAt: number;    // 생성 시점
  autoGenerated: boolean; // 자동 생성 여부
}

interface LocalizationStore {
  [key: string]: LocalizationEntry;
}

// 노드 데이터 - 키 참조만 저장
interface BaseDialogue {
  type: "text" | "choice" | "input";
  speakerKeyRef?: string;  // LocalizationStore의 키 참조
  textKeyRef?: string;     // LocalizationStore의 키 참조
  onEnterCallbackKey?: string;
  onExitCallbackKey?: string;
  isSkippable?: boolean;
}

interface EditorNodeWrapper {
  nodeKey: string;
  dialogue: Dialogue;     // 키 참조만 포함
  position: { x: number; y: number }; // 캔버스 좌표
}

type Scene = Record<string, EditorNodeWrapper>;
type TemplateDialogues = Record<string, Scene>;

// 전체 에디터 상태
interface EditorState {
  currentTemplate: string;
  templateData: TemplateDialogues;
  localizationStore: LocalizationStore;  // ← 새로 추가
  currentScene: string;
  selectedNodeKey?: string;
  lastNodePosition: { x: number; y: number };
}

// MVP 제한사항:
// - 실제 노드 생성은 TextDialogue, ChoiceDialogue만 지원
// - InputDialogue는 타입 정의만 존재하며, 노드 생성 UI는 비활성화
// - 추후 G-06에서 InputDialogue 런타임 속성(정규식, placeholder 등) 확장 예정
```

### 4.3 **키 자동 생성 패턴**

```ts
// 자동 생성 키 패턴
interface KeyGenerationRules {
  speakerKey: "npc_{normalized_name}";     // "NPC 상인" → "npc_npc_상인"
  textKey: "{templateKey}_{sceneKey}_line_{shortId}";
  choiceKey: "{templateKey}_{sceneKey}_choice_{shortId}_{index}";
}

// 키 수정 시 두 단계 편집
interface KeyEditAction {
  type: "UPDATE_ALL" | "CREATE_NEW";
  originalKey: string;
  newKey?: string;
  affectedNodes: string[];
}
```

### 4.4 **파일 구조 예시**

* **JSON Export**:
```json
{
  "dialogue": {
    "intro": {
      "node_001": {
        "nodeKey": "node_001",
        "dialogue": {
          "type": "text",
          "speakerKeyRef": "npc_merchant",
          "textKeyRef": "tutorial_intro_greeting_001"
        },
        "position": { "x": 100, "y": 200 }
      }
    }
  },
  "localization": {
    "npc_merchant": {
      "ko": "NPC 상인",
      "usedBy": ["node_001", "node_003"],
      "createdAt": 1703123456789,
      "autoGenerated": true
    },
    "tutorial_intro_greeting_001": {
      "ko": "어서오세요! 뭘 찾으시나요?",
      "usedBy": ["node_001"],
      "createdAt": 1703123456789,
      "autoGenerated": true
    }
  }
}
```

* **CSV Export** (기존과 동일):
  1. **dialogue.csv** – 대화 데이터 및 선택지 정보
  2. **localization.csv** – 다국어 텍스트 데이터

---

## 5. UX 흐름

```mermaid
flowchart LR
  A[툴 열기] --> B{localStorage 자동 불러오기?}
  B -- 예 --> C[캔버스 + 기존 노드<br/>실제 텍스트 표시]
  B -- 아니오 --> D[빈 캔버스]
  D --> E[Toolbar로 노드 추가]
  C --> E
  E --> F[노드 선택 → 우측 패널<br/>실제 텍스트 입력]
  F --> G[키 자동 생성<br/>아래쪽에 표시]
  G --> H[같은 키 다른 노드<br/>일괄 수정 적용]
  H --> I[유효성 OK?]
  I -- 예 --> J[Export: 실제 텍스트 → 키 매핑]
  I -- 오류 --> K[오류 모달 → 수정]
```

### **기획자 워크플로 시나리오**

1. **컨텐츠 작성**: "NPC 상인", "어서오세요! 뭘 찾으시나요?" 입력
2. **자동 키 생성**: 백그라운드에서 `npc_npc_상인`, `tutorial_intro_line_001` 생성
3. **키 표시**: 입력 필드 아래 작게 표시
4. **반복 텍스트**: "네"라고 입력하면 기존 "네" 키 재사용 여부 묻기
5. **키 수정**: 키 클릭 → 편집 UI → 전체 수정 vs 새 키 분리 선택
6. **Export**: 실제 텍스트가 키로 매핑되어 개발용 데이터 생성

---

## 6. 기술 스택

| 레이어    | 선택 이유                                       |
| ------ | ------------------------------------------- |
| **UI** | React + Vite + TypeScript                   |
| 시각 노드  | React Flow (MIT, 노드/에지 커스텀 쉬움)              |
| 상태     | Zustand (로컬 상태 단순, LocalizationStore 관리)                          |
| 스타일    | Tailwind CSS (CDN 또는 번들, 빠른 프로토)                       |
| 검증     | zod Schema → Re-usable validator            |
| 번들     | 단일 `index.html` + `dist` (GitHub Pages 배포, CDN 리소스 허용) |

---

## 7. 비기능 요건

| 항목      | 목표                                      |
| ------- | --------------------------------------- |
| 성능      | **한 템플릿당 100개 노드 제한** (MVP 고정, 추후 수정 가능)              |
| 브라우저 호환 | Chromium 105+, Firefox 100+, Safari 15+ |
| 보안      | 서버 없는 SPA, 외부 API 요청 없음 (CDN 리소스 허용)                 |
| 접근성     | 기본 키보드 탐색, 폼 ARIA 라벨                    |

---

## 8. Acceptance Criteria (MVP)

| ID    | 시나리오                                             | 기준                          |
| ----- | ------------------------------------------------ | --------------------------- |
| AC-01 | 새 텍스트 노드를 추가해 실제 텍스트 입력 → 노드에 텍스트 표시, Export시 키 매핑        | 노드 표시는 실제 텍스트, JSON은 키 참조             |
| AC-02 | ChoiceDialogue에서 **특정 선택지의 "+" 버튼** 클릭 → 해당 선택지의 nextNodeKey로 새 노드 자동 연결 | 에지가 클릭한 선택지 → 새 node로 정확히 생성 |
| AC-03 | `nextNodeKey`가 비어있는 노드가 있으면 **Export 버튼 비활성화**   | 버튼 disabled & 설명 툴팁         |
| AC-04 | 브라우저 새로고침 후에도 Canvas 레이아웃 복원                     | 노드 좌표 재현, 실제 텍스트 표시                    |
| AC-05 | **JSON Export → JSON Import** 또는 **CSV Export → CSV Import** 직후 데이터 무손실                       | 텍스트-키 매핑 정확히 복원            |
| AC-06 | **같은 텍스트 입력 → 키 재사용 제안**, **키 수정 → 전체/분리 선택**                       | 중복 방지, 의도 명확히 구분            |

---

## 9. 일정·마일스톤 (수정)

| 주차 | 목표                                           |
| -- | -------------------------------------------- |
| 1-3  | 기본 시스템, Import/Export ✅ **완료**   |
| 4  | 자동 키 추천 시스템 ✅ **완료** (재작업 필요)                 |
| **4.5**  | **컨텐츠-키 분리 아키텍처** → LocalizationStore, 실제 텍스트 기반 UI                 |
| 5  | 키 수정 UI (두 단계 편집), 일괄 수정 기능                 |
| 6  | 폴리싱 & QA → GitHub Pages 배포 **(MVP 완료)**      |
| 7+ | 로컬라이징 전용 탭(G-01), 시뮬레이터·콜백 관리 등 착수                |

---

## 10. 리스크 & 대응

| 리스크                | 완화 전략                                                 |
| ------------------ | ----------------------------------------------------- |
| React Flow 러닝커브    | 공식 예제 수정 → 커스텀 노드·에지 단계적 적용                           |
| 대용량 캔버스 성능         | 노드 virtualisation 옵션 · debounced 프리뷰                  |
| 컨텐츠-키 매핑 복잡도         | LocalizationStore 단일 관리, 명확한 키 생성 규칙 |
| CSV ↔ JSON 스키마 불일치 | 단일 Source of Truth → zod Schema 변환기만 두고 UI·I/O는 공통 사용 |

---

## 11. 향후 확장 체크리스트 (요약)

1. **로컬라이징 전용 탭** – key-value 매핑 직접 관리 (우선순위 상승)
2. **In-browser 시뮬레이터** – flags 스탭 포함
3. **콜백 라이브러리 관리** – "callback.json" CRUD
4. **멀티-언어 열 추가 & PO/XLIFF 내보내기**
5. **GitHub Gist/Repo 저장 API** (버전 관리)
6. **다중 사용자 실시간 협업** (WebRTC / CRDT)

---