# 저장 방식 최적화 검토

**티켓 ID**: STORAGE-001  
**생성일**: 2025/06/25 10:06  
**우선순위**: 낮음  
**상태**: 검토 완료

## 개요

현재 localStorage 기반의 즉시 저장 방식에서 메모리 기반 저장 방식으로의 변경 가능성을 검토했습니다.

## 현재 저장 방식 분석

### 구현 방식

-   **Zustand persist 미들웨어**: 모든 상태 변경이 즉시 localStorage에 자동 저장
-   **실시간 동기화**: 노드 추가, 수정, 삭제 등 모든 작업이 즉시 저장
-   **히스토리 관리**: undo/redo를 위한 히스토리도 localStorage에 저장
-   **용량 관리**: StorageManager 컴포넌트로 저장 공간 모니터링 및 정리

### 현재 방식의 장점

1. **데이터 안전성**: 브라우저 크래시나 예기치 않은 종료 시에도 데이터 손실 없음
2. **즉시 복구**: 페이지 새로고침 시 즉시 이전 상태 복원
3. **다중 탭 지원**: 다른 탭에서의 변경사항도 실시간 감지
4. **사용자 편의성**: 별도 저장 버튼 없이 자동 저장

### 현재 방식의 단점

1. **성능 오버헤드**: 모든 상태 변경마다 localStorage I/O 발생
2. **저장 용량 제한**: localStorage는 보통 5-10MB 제한
3. **복잡한 데이터 구조**: 큰 프로젝트에서 JSON 직렬화/역직렬화 비용
4. **동시성 문제**: 다중 탭에서 동시 편집 시 충돌 가능성

## 드래그 최적화 확인 결과

### 현재 드래그 처리 방식

```typescript
// Canvas.tsx의 handleNodesChange
const handleNodesChange = useCallback(
    (changes: NodeChange[]) => {
        changes.forEach((change) => {
            if (change.type === "position" && change.position) {
                // 드래그 중이 아닐 때만 스토어 업데이트 (드래그 완료시)
                if (!change.dragging) {
                    moveNode(change.id, change.position);
                }
            }
        });
        onNodesChange(changes);
    },
    [moveNode, onNodesChange]
);

// 추가로 onNodeDragStop도 있음
const handleNodeDragStop = useCallback(
    (_event: any, node: any) => {
        moveNode(node.id, node.position);
    },
    [moveNode]
);
```

**결론**: 현재는 **드래그 완료 시에만 저장**되고 있어서 이미 최적화되어 있음

## JSON Export/Import vs localStorage 개념 혼란

### 현재 상황

-   **JSON Export/Import**: "프로젝트 저장" / "프로젝트 열기" 버튼으로 명시적 파일 저장/로드
-   **localStorage**: Zustand persist로 자동 저장되는 "임시 작업 공간"

### 사용자 혼란 가능성

1. **개념적 혼란**:

    - "프로젝트 저장" 버튼이 있는데 왜 자동으로 저장되지 않는가?
    - localStorage에 저장된 것과 JSON 파일로 저장된 것의 차이가 무엇인가?

2. **UI 표현 문제**:
    - 현재 "프로젝트 저장" 버튼이 있지만 실제로는 localStorage에 자동 저장됨
    - 사용자는 "저장" 버튼을 눌러야 한다고 생각할 수 있음

## 메모리 기반 저장 방식 검토

### 제안하는 변경 방식

1. **메모리에서만 작업**: 편집 중에는 메모리 상태만 변경
2. **주기적 저장**: 일정 간격(예: 30초)마다 자동 저장
3. **명시적 저장**: 사용자가 저장 버튼을 눌러 즉시 저장
4. **종료 시 저장**: 페이지 종료 시 자동 저장

### 메모리 기반 방식의 장점

1. **성능 향상**: localStorage I/O 횟수 대폭 감소
2. **반응성 개선**: UI 업데이트가 더 빠름
3. **용량 효율성**: 불필요한 중간 상태 저장 방지
4. **개발 복잡성 감소**: 저장 로직 단순화

### 메모리 기반 방식의 단점

1. **데이터 손실 위험**: 브라우저 크래시 시 최근 변경사항 손실
2. **사용자 불편**: 수동 저장 필요성
3. **복구 복잡성**: 저장되지 않은 변경사항 복구 어려움
4. **다중 탭 제한**: 탭 간 동기화 복잡해짐

## 최종 권장사항

### 하이브리드 접근법 추천

현재 프로젝트의 특성을 고려할 때, **완전한 메모리 기반 방식보다는 하이브리드 접근법**을 권장합니다:

1. **주요 작업별 저장**: 노드 추가/삭제, 텍스트 변경 등 중요 작업 시 즉시 저장
2. **주기적 저장**: 30초마다 자동 저장 (현재 상태 백업)
3. **드래그 최적화**: 노드 이동은 드래그 완료 후에만 저장 (이미 구현됨)
4. **사용자 제어**: 저장 버튼 제공으로 즉시 저장 가능

### 구현 우선순위

1. **1단계**: UI 개념 명확화 (버튼명 변경, 저장 상태 표시)
2. **2단계**: 텍스트 편집 최적화 (입력 완료 후 저장)
3. **3단계**: 주기적 자동 저장 추가
4. **4단계**: 저장 상태 표시 (저장됨/저장 중/저장 필요)

### UI 개선 제안

-   "프로젝트 저장" → "프로젝트 내보내기"로 버튼명 변경
-   "프로젝트 열기" → "프로젝트 가져오기"로 버튼명 변경
-   자동 저장 상태 표시 추가 (예: "자동 저장됨" / "저장 중..." / "저장 필요")

## 결론

현재 구현이 이미 상당히 최적화되어 있어서, 완전한 메모리 기반 방식보다는 점진적 개선이 더 적절합니다. 특히 드래그 최적화가 이미 잘 되어 있어서 성능 향상 효과가 제한적일 것으로 예상됩니다.

**우선순위**: 낮음 (현재 방식이 충분히 최적화되어 있음)
**추천 액션**: UI 개념 명확화부터 시작하여 점진적 개선 진행
