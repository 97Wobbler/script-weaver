import type { EditorNodeWrapper, Dialogue, Scene, TemplateDialogues, TextDialogue, ChoiceDialogue } from "../../types/dialogue";
import type { ICoreServices, ExtendedClipboardData, ConnectionInfo } from "../types/editorTypes";
import { useLocalizationStore } from "../localizationStore";
import { cleanupUnusedKeysAfterDeletion } from "../../utils/keyCleanup";

// ÌôïÏû•Îêú ÌÅ¥Î¶ΩÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞ (Î™®Îìà Î†àÎ≤®)
let clipboardData: ExtendedClipboardData = { nodes: [], connections: [] };

/**
 * Node Operations Domain - ÎÖ∏Îìú Î≥µÌï© Ïó∞ÏÇ∞ Í¥ÄÎ¶¨
 *
 * ## üìã Ï£ºÏöî Ï±ÖÏûÑ
 * - **ÎÖ∏Îìú ÏÉùÏÑ±**: ÌÖçÏä§Ìä∏/ÏÑ†ÌÉùÏßÄ ÎÖ∏Îìú ÏÉùÏÑ± Î∞è Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÏÑ§Ï†ï
 * - **ÏûêÎèô Ïó∞Í≤∞**: ÎÖ∏Îìú ÏÉùÏÑ±Í≥º ÎèôÏãúÏóê Î∂ÄÎ™®-ÏûêÏãù Í¥ÄÍ≥Ñ ÏÑ§Ï†ï
 * - **Î≥µÏÇ¨/Î∂ôÏó¨ÎÑ£Í∏∞**: ÌÅ¥Î¶ΩÎ≥¥Îìú Í∏∞Î∞ò ÎÖ∏Îìú Î≥µÏ†ú Î∞è Î∞∞Ïπò
 * - **Îã§Ï§ë ÏûëÏóÖ**: ÏÑ†ÌÉùÎêú Ïó¨Îü¨ ÎÖ∏ÎìúÏùò ÏùºÍ¥Ñ ÏÇ≠Ï†ú/Ïù¥Îèô
 * - **ÏÑ†ÌÉùÏßÄ Í¥ÄÎ¶¨**: ÎèôÏ†Å ÏÑ†ÌÉùÏßÄ Ï∂îÍ∞Ä/Ï†úÍ±∞
 * - **Î≥µÌï© Ïï°ÏÖò**: Ïó¨Îü¨ Îã®Í≥Ñ ÏûëÏóÖÏùÑ ÌïòÎÇòÏùò ÌûàÏä§ÌÜ†Î¶¨Î°ú Í∑∏Î£πÌôî
 *
 * ## üîÑ ÏùòÏ°¥ÏÑ± Í¥ÄÎ¶¨
 * - **Core Services**: ÌÇ§ ÏÉùÏÑ±, Ï†úÌïú Í≤ÄÏ¶ù, Î≥µÌï© Ïï°ÏÖò Í¥ÄÎ¶¨
 * - **Node Core**: Í∏∞Î≥∏ CRUD Ïó∞ÏÇ∞ ÏúÑÏûÑ
 * - **Layout Domain**: ÏûêÎèô Ï†ïÎ†¨ Î∞è ÏúÑÏπò Í≥ÑÏÇ∞
 * - **History Domain**: Î≥µÌï© Ïï°ÏÖò ÏãúÏûë/Ï¢ÖÎ£å
 * - **LocalizationStore**: ÌÖçÏä§Ìä∏ ÌÇ§ ÏÉùÏÑ± Î∞è Ï†ïÎ¶¨
 *
 * ## üéØ ÌïµÏã¨ ÌäπÏßï
 * - **Í∞êÏ∂§‚ÜíÏ†ïÎ†¨‚ÜíÌëúÏãú**: ÏûêÏó∞Ïä§Îü¨Ïö¥ UXÎ•º ÏúÑÌïú ÎÖ∏Îìú ÏÉùÏÑ± ÏàúÏÑú
 * - **Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÌÜµÌï©**: ÎÖ∏Îìú ÏÉùÏÑ± Ïãú ÏûêÎèô ÌÖçÏä§Ìä∏ ÌÇ§ ÏÉùÏÑ±
 * - **ÌÅ¥Î¶ΩÎ≥¥Îìú Í¥ÄÎ¶¨**: Î™®Îìà Î†àÎ≤® ÌÅ¥Î¶ΩÎ≥¥ÎìúÎ°ú Î≥µÏÇ¨/Î∂ôÏó¨ÎÑ£Í∏∞ ÏßÄÏõê
 * - **ÏùºÍ¥Ñ Ï≤òÎ¶¨**: Îã§Ï§ë ÎÖ∏Îìú ÏûëÏóÖÏùò Ìö®Ïú®Ï†Å Ï≤òÎ¶¨
 * - **ÌÇ§ Ï†ïÎ¶¨**: ÎÖ∏Îìú ÏÇ≠Ï†ú Ïãú ÎØ∏ÏÇ¨Ïö© Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÌÇ§ ÏûêÎèô Ï†ïÎ¶¨
 *
 * @description 11Í∞ú public Î©îÏÑúÎìú + 15Í∞ú private Ìó¨Ìçº Î©îÏÑúÎìú
 */
export class NodeOperationsDomain {
  constructor(
    private getState: () => any,
    private setState: (partial: any) => void,
    private coreServices: ICoreServices,
    private updateLocalizationStoreRef: () => void,
    private nodeDomain: any, // NODE CORE DOMAIN ÏùòÏ°¥ÏÑ±
    private layoutDomain: any, // LAYOUT DOMAIN ÏùòÏ°¥ÏÑ±
    private historyDomain: any // HISTORY DOMAIN ÏùòÏ°¥ÏÑ±
  ) {}

  // === ÎÖ∏Îìú ÏÉùÏÑ± (2Í∞ú) ===

  /**
   * ÌÖçÏä§Ìä∏ ÎÖ∏Îìú ÏÉùÏÑ±
   */
  createTextNode(contentText: string = "", speakerText: string = ""): string {
    const validationResult = this.coreServices.validateNodeCountLimit();
    if (!validationResult.isValid) {
      return "";
    }

    const nodeKey = this.coreServices.generateNodeKey();
    const position = this.layoutDomain.getNextNodePosition();

    // Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÌÇ§ ÏÉùÏÑ±
    const localizationStore = useLocalizationStore.getState();
    let textKeyRef: string | undefined;
    let speakerKeyRef: string | undefined;

    if (contentText) {
      const result = localizationStore.generateTextKey(contentText);
      localizationStore.setText(result.key, contentText);
      textKeyRef = result.key;
    }

    if (speakerText) {
      const result = localizationStore.generateSpeakerKey(speakerText);
      localizationStore.setText(result.key, speakerText);
      speakerKeyRef = result.key;
    }

    const dialogue: TextDialogue = {
      type: "text",
      speakerText,
      contentText,
      speakerKeyRef,
      textKeyRef,
    };

    const node: EditorNodeWrapper = {
      nodeKey,
      dialogue,
      position,
      hidden: false,
    };

    this.nodeDomain.addNode(node);
    return nodeKey;
  }

  /**
   * ÏÑ†ÌÉùÏßÄ ÎÖ∏Îìú ÏÉùÏÑ±
   */
  createChoiceNode(contentText: string = "", speakerText: string = ""): string {
    const validationResult = this.coreServices.validateNodeCountLimit();
    if (!validationResult.isValid) {
      return "";
    }

    const nodeKey = this.coreServices.generateNodeKey();
    const position = this.layoutDomain.getNextNodePosition();

    // Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÌÇ§ ÏÉùÏÑ±
    const localizationStore = useLocalizationStore.getState();
    let textKeyRef: string | undefined;
    let speakerKeyRef: string | undefined;

    if (contentText) {
      const result = localizationStore.generateTextKey(contentText);
      localizationStore.setText(result.key, contentText);
      textKeyRef = result.key;
    }

    if (speakerText) {
      const result = localizationStore.generateSpeakerKey(speakerText);
      localizationStore.setText(result.key, speakerText);
      speakerKeyRef = result.key;
    }

    // Í∏∞Î≥∏ ÏÑ†ÌÉùÏßÄ ÏÉùÏÑ±
    const defaultChoices: ChoiceDialogue["choices"] = {
      choice_1: {
        choiceText: "ÏÑ†ÌÉùÏßÄ 1",
        textKeyRef: "",
        nextNodeKey: "",
      },
      choice_2: {
        choiceText: "ÏÑ†ÌÉùÏßÄ 2",
        textKeyRef: "",
        nextNodeKey: "",
      },
    };

    // ÏÑ†ÌÉùÏßÄ Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÏÑ§Ï†ï
    Object.entries(defaultChoices).forEach(([choiceKey, choice]) => {
      if (choice.choiceText) {
        const result = localizationStore.generateChoiceKey(choice.choiceText);
        localizationStore.setText(result.key, choice.choiceText);
        choice.textKeyRef = result.key;
      }
    });

    const dialogue: ChoiceDialogue = {
      type: "choice",
      speakerText,
      contentText,
      speakerKeyRef,
      textKeyRef,
      choices: defaultChoices,
    };

    const node: EditorNodeWrapper = {
      nodeKey,
      dialogue,
      position,
      hidden: false,
    };

    this.nodeDomain.addNode(node);
    return nodeKey;
  }

  // === ÏûêÎèô ÏÉùÏÑ±/Ïó∞Í≤∞ (2Í∞ú) ===

  /**
   * ÏÑ†ÌÉùÏßÄ ÎÖ∏Îìú ÏÉùÏÑ± Î∞è Ïó∞Í≤∞
   */
  async createAndConnectChoiceNode(fromNodeKey: string, choiceKey: string, nodeType: "text" | "choice" = "text"): Promise<string> {
    const validation = this._validateChoiceNodeCreation(fromNodeKey, choiceKey);
    if (!validation.isValid || !validation.fromNode || !validation.choice || !validation.currentScene) {
      return "";
    }

    const { newNodeKey, newNode, tempPosition } = this._createNewChoiceChild(validation.fromNode, fromNodeKey, choiceKey, nodeType);

    this._connectAndUpdateChoiceNode(validation.fromNode, fromNodeKey, choiceKey, validation.choice, newNodeKey, newNode, tempPosition);

    await this._finalizeChoiceNodeCreation(fromNodeKey, newNodeKey);

    return newNodeKey;
  }

  /**
   * ÌÖçÏä§Ìä∏ ÎÖ∏Îìú ÏÉùÏÑ± Î∞è Ïó∞Í≤∞
   */
  async createAndConnectTextNode(fromNodeKey: string, nodeType: "text" | "choice" = "text"): Promise<string> {
    const validation = this._validateTextNodeCreation(fromNodeKey);
    if (!validation.isValid || !validation.fromNode || !validation.currentScene) {
      return "";
    }

    const { newNodeKey, newNode, tempPosition } = this._createNewTextChild(validation.fromNode, fromNodeKey, nodeType);

    this._connectAndUpdateTextNode(validation.fromNode, fromNodeKey, newNodeKey, newNode, tempPosition);

    await this._finalizeTextNodeCreation(fromNodeKey, newNodeKey);

    return newNodeKey;
  }

  // === Î≥µÏÇ¨/Î∂ôÏó¨ÎÑ£Í∏∞ (3Í∞ú) ===

  /**
   * ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ Î≥µÏÇ¨ (ÎÇ¥Î∂Ä Ïó∞Í≤∞ Í¥ÄÍ≥Ñ Ìè¨Ìï®)
   */
  copySelectedNodes(): void {
    const state = this.getState();
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
    if (!currentScene) return;

    // ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ÏùÑ, ÏóÜÏúºÎ©¥ ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Îã®Ïùº ÎÖ∏ÎìúÎ•º Î≥µÏÇ¨
    const targetKeys = state.selectedNodeKeys.size > 0 ? Array.from(state.selectedNodeKeys) : state.selectedNodeKey ? [state.selectedNodeKey] : [];

    const nodesToCopy: EditorNodeWrapper[] = [];
    targetKeys.forEach((nodeKey: string) => {
      const node = this.coreServices.getNode(currentScene, nodeKey);
      if (node) {
        nodesToCopy.push(JSON.parse(JSON.stringify(node)));
      }
    });

    // ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ Í∞ÑÏùò ÎÇ¥Î∂Ä Ïó∞Í≤∞ Í¥ÄÍ≥Ñ Ï∂îÏ∂ú
    const connections = this._extractInternalConnections(targetKeys, currentScene);

    clipboardData = {
      nodes: nodesToCopy,
      connections: connections
    };

    if (state.showToast && nodesToCopy.length > 0) {
      const connectionCount = connections.length;
      const message = connectionCount > 0 
        ? `${nodesToCopy.length}Í∞ú ÎÖ∏ÎìúÏôÄ ${connectionCount}Í∞ú Ïó∞Í≤∞ÏùÑ Î≥µÏÇ¨ÌñàÏäµÎãàÎã§.`
        : `${nodesToCopy.length}Í∞ú ÎÖ∏ÎìúÎ•º Î≥µÏÇ¨ÌñàÏäµÎãàÎã§.`;
      state.showToast(message, "success");
    }
  }

  /**
   * ÎÖ∏Îìú Î∂ôÏó¨ÎÑ£Í∏∞ (ÎÇ¥Î∂Ä Ïó∞Í≤∞ Í¥ÄÍ≥Ñ Î≥µÏõê)
   */
  pasteNodes(position?: { x: number; y: number }): void {
    if (clipboardData.nodes.length === 0) return;

    const state = this.getState();
    const nodesToPaste = clipboardData.nodes.length;

    // 1. Î∂ôÏó¨ÎÑ£Í∏∞ ÏûëÏóÖ Í≤ÄÏ¶ù
    if (!this._validatePasteOperation(nodesToPaste)) {
      return;
    }

    // 2. Î∂ôÏó¨ÎÑ£Í∏∞ ÏúÑÏπò Í≥ÑÏÇ∞
    const startX = position?.x ?? state.lastNodePosition.x + 50;
    const startY = position?.y ?? state.lastNodePosition.y + 50;

    // 3. ÏÉà ÎÖ∏ÎìúÎì§ ÏÉùÏÑ± Î∞è ID Îß§Ìïë ÌÖåÏù¥Î∏î ÏÉùÏÑ±
    const { newNodes, newNodeKeys, nodeIdMapping } = this._createPastedNodesWithMapping(startX, startY);

    // 4. Î™®Îì† ÎÖ∏ÎìúÎ•º Ìïú Î≤àÏóê Ï∂îÍ∞Ä
    this.setState((currentState: any) => {
      let updatedState = { ...currentState };

      newNodes.forEach((node) => {
        const newTemplateData = this._ensureSceneExists(updatedState.templateData, updatedState.currentTemplate, updatedState.currentScene);

        const currentScene = newTemplateData[updatedState.currentTemplate][updatedState.currentScene];
        const updatedScene = this.coreServices.setNode(currentScene, node.nodeKey, node);

        updatedState = {
          ...updatedState,
          templateData: {
            ...newTemplateData,
            [updatedState.currentTemplate]: {
              ...newTemplateData[updatedState.currentTemplate],
              [updatedState.currentScene]: updatedScene,
            },
          },
          lastNodePosition: node.position,
          selectedNodeKey: node.nodeKey,
        };
      });

      return {
        ...updatedState,
        selectedNodeKeys: new Set(newNodeKeys),
      };
    });

    // 5. Ïó∞Í≤∞ Í¥ÄÍ≥Ñ Î≥µÏõê
    const restoredConnections = this._restoreConnections(nodeIdMapping);

    // 6. ÏÉÅÌÉú Î≥ÄÍ≤Ω ÌõÑÏóê ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï∂îÍ∞Ä
    this.coreServices.pushToHistory("ÎÖ∏Îìú Î∂ôÏó¨ÎÑ£Í∏∞");
    this.updateLocalizationStoreRef();

    if (state.showToast) {
      const message = restoredConnections > 0 
        ? `${clipboardData.nodes.length}Í∞ú ÎÖ∏ÎìúÏôÄ ${restoredConnections}Í∞ú Ïó∞Í≤∞ÏùÑ Î∂ôÏó¨ÎÑ£ÏóàÏäµÎãàÎã§.`
        : `${clipboardData.nodes.length}Í∞ú ÎÖ∏ÎìúÎ•º Î∂ôÏó¨ÎÑ£ÏóàÏäµÎãàÎã§.`;
      state.showToast(message, "success");
    }
  }

  /**
   * ÎÖ∏Îìú Î≥µÏ†ú
   */
  duplicateNode(nodeKey: string): string {
    const state = this.getState();
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
    if (!currentScene) return "";

    const originalNode = this.coreServices.getNode(currentScene, nodeKey);
    if (!originalNode) return "";

    // ÏûÑÏãúÎ°ú ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Ï†ÄÏû•ÌïòÍ≥† Î∂ôÏó¨ÎÑ£Í∏∞ (Îã®Ïùº ÎÖ∏ÎìúÎäî Ïó∞Í≤∞ ÏóÜÏùå)
    const originalClipboard = { ...clipboardData };
    clipboardData = { 
      nodes: [originalNode], 
      connections: [] 
    };

    this.pasteNodes({
      x: originalNode.position.x + 50,
      y: originalNode.position.y + 50,
    });

    // ÌÅ¥Î¶ΩÎ≥¥Îìú Î≥µÏõê
    clipboardData = originalClipboard;

    return state.selectedNodeKeys.size > 0 ? (Array.from(state.selectedNodeKeys)[0] as string) : "";
  }

  // === Îã§Ï§ë ÏûëÏóÖ (2Í∞ú) ===

  /**
   * ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ ÏÇ≠Ï†ú
   */
  deleteSelectedNodes(): void {
    const { targetKeys, currentScene } = this._getNodesForDeletion();
    if (targetKeys.length === 0 || !currentScene) return;

    // ÏÉàÎ°úÏö¥ Î∞©Ïãù: ÏÇ≠Ï†ú ÌõÑ Ï†ÑÏ≤¥ Ïä§Ï∫îÌïòÏó¨ ÌÇ§ Ï†ïÎ¶¨
    this._performNodesDeletion(targetKeys);

    // ÏÇ≠Ï†ú ÌõÑ ÌòÑÏû¨ Ïî¨ ÏÉÅÌÉúÎ•º Í∞ÄÏ†∏ÏôÄÏÑú ÌÇ§ Ï†ïÎ¶¨
    const updatedState = this.getState();
    const updatedScene = updatedState.templateData[updatedState.currentTemplate]?.[updatedState.currentScene];
    cleanupUnusedKeysAfterDeletion(updatedScene);

    this._finalizeNodesDeletion(targetKeys);
  }

  /**
   * ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ Ïù¥Îèô
   */
  moveSelectedNodes(deltaX: number, deltaY: number): void {
    const state = this.getState();
    const targetKeys = state.selectedNodeKeys.size > 0 ? Array.from(state.selectedNodeKeys) : state.selectedNodeKey ? [state.selectedNodeKey] : [];

    targetKeys.forEach((nodeKey: string) => {
      const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
      if (!currentScene) return;

      const node = this.coreServices.getNode(currentScene, nodeKey);
      if (node) {
        this.nodeDomain.moveNode(nodeKey, {
          x: node.position.x + deltaX,
          y: node.position.y + deltaY,
        });
      }
    });
  }

  // === ÏÑ†ÌÉùÏßÄ Í¥ÄÎ¶¨ (2Í∞ú) ===

  /**
   * ÏÑ†ÌÉùÏßÄ Ï∂îÍ∞Ä
   */
  addChoice(nodeKey: string, choiceKey: string, choiceText: string, nextNodeKey: string = ""): void {
    const state = this.getState();
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
    if (!currentScene) return;

    const node = this.coreServices.getNode(currentScene, nodeKey);
    if (!node || node.dialogue.type !== "choice") return;

    // Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÌÇ§ ÏÉùÏÑ±
    const localizationStore = useLocalizationStore.getState();
    const result = localizationStore.generateChoiceKey(choiceText);
    localizationStore.setText(result.key, choiceText);

    const updatedChoices = {
      ...node.dialogue.choices,
      [choiceKey]: {
        choiceText,
        textKeyRef: result.key,
        nextNodeKey,
      },
    };

    this.nodeDomain.updateNode(nodeKey, {
      dialogue: {
        ...node.dialogue,
        choices: updatedChoices,
      },
    });
  }

  /**
   * ÏÑ†ÌÉùÏßÄ Ï†úÍ±∞
   */
  removeChoice(nodeKey: string, choiceKey: string): void {
    const state = this.getState();
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
    if (!currentScene) return;

    const node = this.coreServices.getNode(currentScene, nodeKey);
    if (!node || node.dialogue.type !== "choice") return;

    const choice = node.dialogue.choices?.[choiceKey];
    if (!choice) return;

    // Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÌÇ§ Ï†ïÎ¶¨
    const localizationStore = useLocalizationStore.getState();
    if (choice.textKeyRef) {
      localizationStore.deleteKey(choice.textKeyRef);
    }

    const updatedChoices = { ...node.dialogue.choices };
    delete updatedChoices[choiceKey];

    this.nodeDomain.updateNode(nodeKey, {
      dialogue: {
        ...node.dialogue,
        choices: updatedChoices,
      },
    });
  }

  // === Ìó¨Ìçº Î©îÏÑúÎìúÎì§ ===

  // Î∂ôÏó¨ÎÑ£Í∏∞ Í¥ÄÎ†® Ìó¨ÌçºÎì§
  private _validatePasteOperation(nodesToPaste: number): boolean {
    const state = this.getState();
    const currentNodeCount = this.nodeDomain.getCurrentNodeCount();
    const totalAfterPaste = currentNodeCount + nodesToPaste;

    if (totalAfterPaste > 100) {
      if (state.showToast) {
        state.showToast(`ÎÖ∏Îìú Í∞úÏàò Ï†úÌïú Ï¥àÍ≥º: ÌòÑÏû¨ ${currentNodeCount}Í∞ú + Î∂ôÏó¨ÎÑ£Í∏∞ ${nodesToPaste}Í∞ú = ${totalAfterPaste}Í∞ú (ÏµúÎåÄ 100Í∞ú)`, "warning");
      }
      return false;
    }
    return true;
  }

  private _setupPastedNodeLocalization(newNode: EditorNodeWrapper): void {
    const localizationStore = useLocalizationStore.getState();

    if (newNode.dialogue.type === "text" || newNode.dialogue.type === "choice") {
      // ÌôîÏûê ÌÖçÏä§Ìä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÉà ÌÇ§ ÏÉùÏÑ±
      if (newNode.dialogue.speakerText) {
        const result = localizationStore.generateSpeakerKey(newNode.dialogue.speakerText);
        localizationStore.setText(result.key, newNode.dialogue.speakerText);
        newNode.dialogue.speakerKeyRef = result.key;
      }

      // ÎÇ¥Ïö© ÌÖçÏä§Ìä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÉà ÌÇ§ ÏÉùÏÑ±
      if (newNode.dialogue.contentText) {
        const result = localizationStore.generateTextKey(newNode.dialogue.contentText);
        localizationStore.setText(result.key, newNode.dialogue.contentText);
        newNode.dialogue.textKeyRef = result.key;
      }
    }

    // ÏÑ†ÌÉùÏßÄ ÌÖçÏä§Ìä∏Îì§ÎèÑ ÏÉà ÌÇ§ ÏÉùÏÑ±
    if (newNode.dialogue.type === "choice" && newNode.dialogue.choices) {
      Object.entries(newNode.dialogue.choices).forEach(([choiceKey, choice]) => {
        if (choice.choiceText) {
          const result = localizationStore.generateChoiceKey(choice.choiceText);
          localizationStore.setText(result.key, choice.choiceText);
          choice.textKeyRef = result.key;
        }
        // Ïó∞Í≤∞Îêú ÎÖ∏Îìú Ï∞∏Ï°∞Îäî Ï†úÍ±∞ (Î≥µÏÇ¨Îêú ÎÖ∏ÎìúÎäî Ïó∞Í≤∞ ÏóÜÏùå)
        choice.nextNodeKey = "";
      });
    }

    // ÌÖçÏä§Ìä∏ ÎÖ∏ÎìúÏùò Ïó∞Í≤∞ÎèÑ Ï†úÍ±∞
    if (newNode.dialogue.type === "text") {
      newNode.dialogue.nextNodeKey = undefined;
    }
  }

  /**
   * Î∂ôÏó¨ÎÑ£Í∏∞Ïö© ÎÖ∏ÎìúÎì§ÏùÑ ÏÉùÏÑ±ÌïòÍ≥† ID Îß§ÌïëÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
   */
  private _createPastedNodesWithMapping(startX: number, startY: number): { 
    newNodes: EditorNodeWrapper[]; 
    newNodeKeys: string[]; 
    nodeIdMapping: Map<string, string> 
  } {
    const newNodeKeys: string[] = [];
    const newNodes: EditorNodeWrapper[] = [];
    const nodeIdMapping = new Map<string, string>(); // Í∏∞Ï°¥ ÎÖ∏Îìú ID ‚Üí ÏÉà ÎÖ∏Îìú ID

    // ÏõêÎ≥∏ ÎÖ∏ÎìúÎì§Ïùò Í≤ΩÍ≥Ñ Î∞ïÏä§ Í≥ÑÏÇ∞ (ÏÉÅÎåÄÏ†Å ÏúÑÏπò Î≥¥Ï°¥ÏùÑ ÏúÑÌï¥)
    const originalPositions = clipboardData.nodes.map(node => node.position);
    const minX = Math.min(...originalPositions.map(pos => pos.x));
    const minY = Math.min(...originalPositions.map(pos => pos.y));

    // ÏÉà ÎÖ∏ÎìúÎì§ÏùÑ Ï§ÄÎπÑ (ÏÉÅÎåÄÏ†Å ÏúÑÏπò Î≥¥Ï°¥)
    clipboardData.nodes.forEach((originalNode, index) => {
      const newNodeKey = this.coreServices.generateNodeKey();
      
      // ÏÉÅÎåÄÏ†Å ÏúÑÏπò Í≥ÑÏÇ∞: ÏõêÎ≥∏Ïùò ÏÉÅÎåÄ ÏúÑÏπòÎ•º Ïú†ÏßÄÌïòÎ©¥ÏÑú ÏÉà ÏãúÏûëÏ†êÏúºÎ°ú Ïù¥Îèô
      const relativeX = originalNode.position.x - minX;
      const relativeY = originalNode.position.y - minY;
      const newPosition = {
        x: startX + relativeX,
        y: startY + relativeY,
      };
      
      const newNode: EditorNodeWrapper = {
        ...JSON.parse(JSON.stringify(originalNode)),
        nodeKey: newNodeKey,
        position: newPosition,
      };

      // ID Îß§Ìïë Ï†ÄÏû•
      nodeIdMapping.set(originalNode.nodeKey, newNodeKey);

      // Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖò ÏÑ§Ï†ï (Ïó∞Í≤∞ Ï†úÍ±∞Îäî ÌïòÏßÄ ÏïäÏùå - ÎÇòÏ§ëÏóê Î≥µÏõêÌï† ÏòàÏ†ï)
      this._setupPastedNodeLocalizationWithoutConnectionCleanup(newNode);

      newNodes.push(newNode);
      newNodeKeys.push(newNodeKey);
    });
    return { newNodes, newNodeKeys, nodeIdMapping };
  }

  // ÏÇ≠Ï†ú Í¥ÄÎ†® Ìó¨ÌçºÎì§
  private _getNodesForDeletion(): { targetKeys: string[]; currentScene: Scene | null } {
    const state = this.getState();
    const targetKeys = state.selectedNodeKeys.size > 0 ? Array.from(state.selectedNodeKeys) : state.selectedNodeKey ? [state.selectedNodeKey] : [];
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene] || null;

    return { targetKeys, currentScene };
  }

  private _performNodesDeletion(targetKeys: string[]): void {
    targetKeys.forEach((nodeKey) => {
      this.nodeDomain.deleteNode(nodeKey, { recordHistory: false, skipKeyCleanup: true }); // ÌÇ§ Ï†ïÎ¶¨Îäî ÎßàÏßÄÎßâÏóê ÏùºÍ¥Ñ Ï≤òÎ¶¨
    });
  }

  private _finalizeNodesDeletion(targetKeys: string[]): void {
    // ÏÑ†ÌÉù ÏÉÅÌÉú Ï†ïÎ¶¨
    this.nodeDomain.clearSelection();

    // ÌûàÏä§ÌÜ†Î¶¨ Ï∂îÍ∞Ä (ÌÜµÌï© ÌûàÏä§ÌÜ†Î¶¨)
    this.coreServices.pushToHistory(`${targetKeys.length}Í∞ú ÎÖ∏Îìú ÏÇ≠Ï†ú`);
    this.updateLocalizationStoreRef();
  }

  // Ïú†Ìã∏Î¶¨Ìã∞ Ìó¨ÌçºÎì§
  private _ensureSceneExists(templateData: TemplateDialogues, templateKey: string, sceneKey: string): TemplateDialogues {
    if (!templateData[templateKey]) {
      templateData = {
        ...templateData,
        [templateKey]: {},
      };
    }

    if (!templateData[templateKey][sceneKey]) {
      templateData = {
        ...templateData,
        [templateKey]: {
          ...templateData[templateKey],
          [sceneKey]: {},
        },
      };
    }

    return templateData;
  }

  private _createBaseTextDialogue(speakerText: string = "", contentText: string = "", speakerKeyRef?: string, textKeyRef?: string, nextNodeKey?: string): TextDialogue {
    return {
      type: "text",
      speakerText,
      contentText,
      speakerKeyRef,
      textKeyRef,
      nextNodeKey,
    };
  }

  private _createBaseChoiceDialogue(
    speakerText: string = "",
    contentText: string = "",
    speakerKeyRef?: string,
    textKeyRef?: string,
    choices: ChoiceDialogue["choices"] = {}
  ): ChoiceDialogue {
    const defaultChoices =
      choices && Object.keys(choices).length > 0
        ? choices
        : {
            choice_1: {
              choiceText: "ÏÑ†ÌÉùÏßÄ 1",
              textKeyRef: "",
              nextNodeKey: "",
            },
            choice_2: {
              choiceText: "ÏÑ†ÌÉùÏßÄ 2",
              textKeyRef: "",
              nextNodeKey: "",
            },
          };

    return {
      type: "choice",
      speakerText,
      contentText,
      speakerKeyRef,
      textKeyRef,
      choices: defaultChoices,
    };
  }

  // ÎÖ∏Îìú ÏÉùÏÑ±/Ïó∞Í≤∞ Ìó¨ÌçºÎì§
  private _validateChoiceNodeCreation(
    fromNodeKey: string,
    choiceKey: string
  ): {
    isValid: boolean;
    fromNode: EditorNodeWrapper | null;
    choice: any | null;
    currentScene: Scene | null;
  } {
    const compoundActionId = this.historyDomain.startCompoundAction(`ÏÑ†ÌÉùÏßÄÏóêÏÑú ÏÉà ÎÖ∏Îìú ÏÉùÏÑ±: ${fromNodeKey} -> ${choiceKey}`);

    const validationResult = this.coreServices.validateNodeCountLimit({ endCompoundAction: true });
    if (!validationResult.isValid) {
      return { isValid: false, fromNode: null, choice: null, currentScene: null };
    }

    const state = this.getState();
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
    if (!currentScene) {
      this.coreServices.endCompoundAction();
      return { isValid: false, fromNode: null, choice: null, currentScene: null };
    }

    const fromNode = this.coreServices.getNode(currentScene, fromNodeKey);
    if (!fromNode || fromNode.dialogue.type !== "choice") {
      this.coreServices.endCompoundAction();
      return { isValid: false, fromNode: null, choice: null, currentScene: null };
    }

    const choice = fromNode.dialogue.choices?.[choiceKey];
    if (!choice) {
      this.coreServices.endCompoundAction();
      return { isValid: false, fromNode: null, choice: null, currentScene: null };
    }

    return { isValid: true, fromNode, choice, currentScene };
  }

  private _createNewChoiceChild(
    fromNode: EditorNodeWrapper,
    fromNodeKey: string,
    choiceKey: string,
    nodeType: "text" | "choice"
  ): { newNodeKey: string; newNode: EditorNodeWrapper; tempPosition: { x: number; y: number } } {
    const newNodeKey = this.coreServices.generateNodeKey();
    const tempPosition = this.layoutDomain.calculateChildNodePosition(fromNodeKey, choiceKey);

    let dialogue: Dialogue;
    if (nodeType === "choice") {
      dialogue = this._createBaseChoiceDialogue();
    } else {
      dialogue = this._createBaseTextDialogue();
    }

    const newNode: EditorNodeWrapper = {
      nodeKey: newNodeKey,
      dialogue,
      position: tempPosition,
      hidden: true, // Í∞êÏ∂∞ÏßÑ ÏÉÅÌÉúÎ°ú ÏÉùÏÑ±
    };

    return { newNodeKey, newNode, tempPosition };
  }

  private _connectAndUpdateChoiceNode(
    fromNode: EditorNodeWrapper,
    fromNodeKey: string,
    choiceKey: string,
    choice: any,
    newNodeKey: string,
    newNode: EditorNodeWrapper,
    tempPosition: { x: number; y: number }
  ): void {
    // ÏÉà ÎÖ∏Îìú Ï∂îÍ∞Ä
    this.nodeDomain.addNode(newNode);

    // ÏÑ†ÌÉùÏßÄ Ïó∞Í≤∞ ÏóÖÎç∞Ïù¥Ìä∏
    const updatedChoice = { ...choice, nextNodeKey: newNodeKey };
    const updatedChoices = { ...(fromNode.dialogue as ChoiceDialogue).choices, [choiceKey]: updatedChoice };

    this.nodeDomain.updateNode(fromNodeKey, {
      dialogue: {
        ...fromNode.dialogue,
        choices: updatedChoices,
      },
    });
  }

  private async _finalizeChoiceNodeCreation(fromNodeKey: string, newNodeKey: string): Promise<void> {
    // ÏÑ†ÌÉù ÎÖ∏ÎìúÎ•º ÏÉàÎ°ú ÏÉùÏÑ±Îêú ÎÖ∏ÎìúÎ°ú Î≥ÄÍ≤Ω
    this.nodeDomain.setSelectedNode(newNodeKey);

    // ÏûêÏãù ÎÖ∏ÎìúÎì§ Ï†ïÎ†¨ (ÏúÑÏπò Ï°∞Ï†ï)
    await this.layoutDomain.arrangeSelectedNodeChildren(fromNodeKey, true);

    // Ï†ïÎ†¨ ÏôÑÎ£å ÌõÑ ÏÉà ÎÖ∏Îìú ÎÇòÌÉÄÎÇ¥Í∏∞
    this.nodeDomain.updateNodeVisibility(newNodeKey, false);

    this.coreServices.endCompoundAction();
  }

  private _validateTextNodeCreation(fromNodeKey: string): {
    isValid: boolean;
    fromNode: EditorNodeWrapper | null;
    currentScene: Scene | null;
  } {
    const compoundActionId = this.historyDomain.startCompoundAction(`ÌÖçÏä§Ìä∏ ÎÖ∏ÎìúÏóêÏÑú ÏÉà ÎÖ∏Îìú ÏÉùÏÑ±: ${fromNodeKey}`);

    const validationResult = this.coreServices.validateNodeCountLimit({ endCompoundAction: true });
    if (!validationResult.isValid) {
      return { isValid: false, fromNode: null, currentScene: null };
    }

    const state = this.getState();
    const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
    if (!currentScene) {
      this.coreServices.endCompoundAction();
      return { isValid: false, fromNode: null, currentScene: null };
    }

    const fromNode = this.coreServices.getNode(currentScene, fromNodeKey);
    if (!fromNode || fromNode.dialogue.type !== "text") {
      this.coreServices.endCompoundAction();
      return { isValid: false, fromNode: null, currentScene: null };
    }

    return { isValid: true, fromNode, currentScene };
  }

  private _createNewTextChild(
    fromNode: EditorNodeWrapper,
    fromNodeKey: string,
    nodeType: "text" | "choice"
  ): { newNodeKey: string; newNode: EditorNodeWrapper; tempPosition: { x: number; y: number } } {
    const newNodeKey = this.coreServices.generateNodeKey();
    const tempPosition = this.layoutDomain.calculateChildNodePosition(fromNodeKey);

    let dialogue: Dialogue;
    if (nodeType === "choice") {
      dialogue = this._createBaseChoiceDialogue();
    } else {
      dialogue = this._createBaseTextDialogue();
    }

    const newNode: EditorNodeWrapper = {
      nodeKey: newNodeKey,
      dialogue,
      position: tempPosition,
      hidden: true, // Í∞êÏ∂∞ÏßÑ ÏÉÅÌÉúÎ°ú ÏÉùÏÑ±
    };

    return { newNodeKey, newNode, tempPosition };
  }

  private _connectAndUpdateTextNode(
    fromNode: EditorNodeWrapper,
    fromNodeKey: string,
    newNodeKey: string,
    newNode: EditorNodeWrapper,
    tempPosition: { x: number; y: number }
  ): void {
    // ÏÉà ÎÖ∏Îìú Ï∂îÍ∞Ä
    this.nodeDomain.addNode(newNode);

    // ÌÖçÏä§Ìä∏ ÎÖ∏Îìú Ïó∞Í≤∞ ÏóÖÎç∞Ïù¥Ìä∏
    this.nodeDomain.updateNode(fromNodeKey, {
      dialogue: {
        ...fromNode.dialogue,
        nextNodeKey: newNodeKey,
      },
    });
  }

  private async _finalizeTextNodeCreation(fromNodeKey: string, newNodeKey: string): Promise<void> {
    // ÏÑ†ÌÉù ÎÖ∏ÎìúÎ•º ÏÉàÎ°ú ÏÉùÏÑ±Îêú ÎÖ∏ÎìúÎ°ú Î≥ÄÍ≤Ω
    this.nodeDomain.setSelectedNode(newNodeKey);

    // ÏûêÏãù ÎÖ∏ÎìúÎì§ Ï†ïÎ†¨ (ÏúÑÏπò Ï°∞Ï†ï)
    await this.layoutDomain.arrangeSelectedNodeChildren(fromNodeKey, true);

    // Ï†ïÎ†¨ ÏôÑÎ£å ÌõÑ ÏÉà ÎÖ∏Îìú ÎÇòÌÉÄÎÇ¥Í∏∞
    this.nodeDomain.updateNodeVisibility(newNodeKey, false);

    this.coreServices.endCompoundAction();
  }

  // === Î≥µÏÇ¨/Î∂ôÏó¨ÎÑ£Í∏∞ Í≥†ÎèÑÌôî Ìó¨Ìçº Î©îÏÑúÎìúÎì§ ===

    /**
   * ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ Í∞ÑÏùò ÎÇ¥Î∂Ä Ïó∞Í≤∞ Í¥ÄÍ≥ÑÎ•º Ï∂îÏ∂úÌï©ÎãàÎã§.
   */
  private _extractInternalConnections(selectedNodeKeys: string[], currentScene: Scene): ConnectionInfo[] {
    const connections: ConnectionInfo[] = [];
    const selectedKeySet = new Set(selectedNodeKeys);

    selectedNodeKeys.forEach(nodeKey => {
      const node = this.coreServices.getNode(currentScene, nodeKey);
      if (!node) return;

      // ÌÖçÏä§Ìä∏ ÎÖ∏ÎìúÏùò nextNodeKey Ï≤¥ÌÅ¨
      if (node.dialogue.type === "text" && node.dialogue.nextNodeKey) {
        const targetKey = node.dialogue.nextNodeKey;
        const isInternal = selectedKeySet.has(targetKey);
        
        if (isInternal) {
          connections.push({
            sourceNodeKey: nodeKey,
            targetNodeKey: targetKey,
            connectionType: "text"
          });
        }
      }

      // ÏÑ†ÌÉùÏßÄ ÎÖ∏ÎìúÏùò Í∞Å ÏÑ†ÌÉùÏßÄ nextNodeKey Ï≤¥ÌÅ¨
      if (node.dialogue.type === "choice" && node.dialogue.choices) {
        const choiceDialogue = node.dialogue as ChoiceDialogue;
        Object.entries(choiceDialogue.choices).forEach(([choiceKey, choice]) => {
          if (choice.nextNodeKey) {
            const isInternal = selectedKeySet.has(choice.nextNodeKey);
            
            if (isInternal) {
              connections.push({
                sourceNodeKey: nodeKey,
                targetNodeKey: choice.nextNodeKey,
                connectionType: "choice",
                choiceKey: choiceKey
              });
            }
          }
        });
      }
    });
    return connections;
  }

  /**
   * Î∂ôÏó¨ÎÑ£Í∏∞ Ïãú Ïó∞Í≤∞ Í¥ÄÍ≥ÑÎ•º Î≥µÏõêÌï©ÎãàÎã§.
   */
  private _restoreConnections(nodeIdMapping: Map<string, string>): number {
    const state = this.getState();
    let restoredCount = 0;

    // ÎÖ∏ÎìúÎ≥ÑÎ°ú Ïó∞Í≤∞ÏùÑ Í∑∏Î£πÌôîÌïòÏó¨ Ìïú Î≤àÏóê ÏóÖÎç∞Ïù¥Ìä∏
    const nodeUpdates = new Map<string, any>();

    clipboardData.connections.forEach((connection, index) => {
      const newSourceKey = nodeIdMapping.get(connection.sourceNodeKey);
      const newTargetKey = nodeIdMapping.get(connection.targetNodeKey);

      if (!newSourceKey || !newTargetKey) {
        return;
      }

      const currentScene = state.templateData[state.currentTemplate]?.[state.currentScene];
      if (!currentScene) {
        return;
      }

      const sourceNode = this.coreServices.getNode(currentScene, newSourceKey);
      if (!sourceNode) {
        return;
      }

      if (connection.connectionType === "text" && sourceNode.dialogue.type === "text") {
        // ÌÖçÏä§Ìä∏ ÎÖ∏Îìú Ïó∞Í≤∞ Î≥µÏõê
        nodeUpdates.set(newSourceKey, {
          dialogue: {
            ...sourceNode.dialogue,
            nextNodeKey: newTargetKey
          }
        });
        restoredCount++;
      } else if (connection.connectionType === "choice" && connection.choiceKey && sourceNode.dialogue.type === "choice") {
        // ÏÑ†ÌÉùÏßÄ ÎÖ∏Îìú Ïó∞Í≤∞ Î≥µÏõê - Í∏∞Ï°¥ ÏóÖÎç∞Ïù¥Ìä∏ÏôÄ Î≥ëÌï©
        const choiceDialogue = sourceNode.dialogue as ChoiceDialogue;
        const choice = choiceDialogue.choices[connection.choiceKey];
        
        if (choice) {
          // Í∏∞Ï°¥ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† Î≥ëÌï©
          const existingUpdate = nodeUpdates.get(newSourceKey);
          const baseChoices = existingUpdate?.dialogue?.choices || choiceDialogue.choices;
          
          const updatedChoices = {
            ...baseChoices,
            [connection.choiceKey]: {
              ...choice,
              nextNodeKey: newTargetKey
            }
          };
          
          nodeUpdates.set(newSourceKey, {
            dialogue: {
              ...sourceNode.dialogue,
              choices: updatedChoices
            }
          });
          
          restoredCount++;
        }
      }
    });

    // Ìïú Î≤àÏóê Î™®Îì† ÎÖ∏Îìú ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
    nodeUpdates.forEach((update, nodeKey) => {
      this.nodeDomain.updateNode(nodeKey, update);
    });

    
    return restoredCount;
  }

    /**
   * Ïó∞Í≤∞ Ï†úÍ±∞ ÏóÜÏù¥ Î°úÏª¨ÎùºÏù¥Ï†úÏù¥ÏÖòÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§.
   */
  private _setupPastedNodeLocalizationWithoutConnectionCleanup(newNode: EditorNodeWrapper): void {
    const localizationStore = useLocalizationStore.getState();

    if (newNode.dialogue.type === "text" || newNode.dialogue.type === "choice") {
      // ÌôîÏûê ÌÖçÏä§Ìä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÉà ÌÇ§ ÏÉùÏÑ±
      if (newNode.dialogue.speakerText) {
        const result = localizationStore.generateSpeakerKey(newNode.dialogue.speakerText);
        localizationStore.setText(result.key, newNode.dialogue.speakerText);
        newNode.dialogue.speakerKeyRef = result.key;
      }

      // ÎÇ¥Ïö© ÌÖçÏä§Ìä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÉà ÌÇ§ ÏÉùÏÑ±
      if (newNode.dialogue.contentText) {
        const result = localizationStore.generateTextKey(newNode.dialogue.contentText);
        localizationStore.setText(result.key, newNode.dialogue.contentText);
        newNode.dialogue.textKeyRef = result.key;
      }
    }

    // ÏÑ†ÌÉùÏßÄ ÌÖçÏä§Ìä∏Îì§ÎèÑ ÏÉà ÌÇ§ ÏÉùÏÑ± (Ïó∞Í≤∞ÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ)
    if (newNode.dialogue.type === "choice" && newNode.dialogue.choices) {
      const choiceDialogue = newNode.dialogue as ChoiceDialogue;
      Object.entries(choiceDialogue.choices).forEach(([choiceKey, choice]) => {
        if (choice.choiceText) {
          const result = localizationStore.generateChoiceKey(choice.choiceText);
          localizationStore.setText(result.key, choice.choiceText);
          choice.textKeyRef = result.key;
        }
        // nextNodeKeyÎäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ (ÎÇòÏ§ëÏóê Îß§ÌïëÏùÑ ÌÜµÌï¥ ÏóÖÎç∞Ïù¥Ìä∏)
      });
    }

    // ÌÖçÏä§Ìä∏ ÎÖ∏ÎìúÏùò nextNodeKeyÎèÑ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ (ÎÇòÏ§ëÏóê Îß§ÌïëÏùÑ ÌÜµÌï¥ ÏóÖÎç∞Ïù¥Ìä∏)
  }
}

/**
 * Node Operations Domain Ìå©ÌÜ†Î¶¨ Ìï®Ïàò
 */
export function createNodeOperationsDomain(
  getState: () => any,
  setState: (partial: any) => void,
  coreServices: ICoreServices,
  updateLocalizationStoreRef: () => void,
  nodeDomain: any,
  layoutDomain: any,
  historyDomain: any
): NodeOperationsDomain {
  return new NodeOperationsDomain(getState, setState, coreServices, updateLocalizationStoreRef, nodeDomain, layoutDomain, historyDomain);
}
